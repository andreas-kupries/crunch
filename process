#!/usr/bin/env tclsh
# -*- tcl -*-

# Arguments.
#
# state - database holding processing state for easy restart after an
#         abort. I.e. restart at point of abort, without re-doing the
#	  completed parts. database is created if not existing.
#
# repo  - fossil repository we are working from.
#
# cmd   - Command run per revision. List. Contains command and arguments.

# Results.
#
# * Runs the command per revision.
# * CWD/src - Checkout of the current revision.

package require Tcl 8.5
package require sqlite3

if {[llength $argv] < 3} {
    puts stderr "Usage: $argv0 state repository cmd ..."
    exit 1
}

set cargs [lassign $argv state repo cmd]
set cmd [file normalize $cmd]

if {![file exists $repo]} {
    puts stderr "Usage: $argv0 state repository cmd ...\nrepository does not exist"
    exit 1
}

set repo [file normalize $repo]
set base [file normalize [pwd]]

sqlite3 DB $repo

set has [file exists $state]
DB eval {
    ATTACH DATABASE $state AS STATE
}
if {!$has} {
    # Generate structures to hold the processing state.
    DB eval {
	-- Table of revisions we have fully processed.
	CREATE TABLE STATE.done ( uuid TEXT PRIMARY KEY );
    }
}

puts {SETUP CHECKOUT ...}
# Generate a checkout of the chosen revision under the current
# working directory.

file delete -force src
file mkdir src
cd src
exec >@ stdout 2>@ stderr fossil open $repo
cd ..

# Pull timeline, exclude anything we have done already, and then run
# the command on the remaining revisions, in order from past to future.

# NOTE: We do not care about branches and the like. We are _not_
# following the links between revisions. We are processing them in
# order of commit. When more than one branch is present we essentially
# run breadth-first, not depth-first.

puts {PROCESS...}

set count 0
DB eval {
    SELECT B.uuid
    FROM plink L, blob B
    WHERE B.rid = L.cid
    AND   B.uuid NOT IN STATE.done
    AND   L.isprim
    ORDER BY L.mtime DESC
} values {
    set uuid $values(uuid)

    puts "======================================================="
    puts "Processing : $uuid"

    cd src
    exec >@ stdout 2>@ stderr fossil update $uuid
    cd ..

    puts "Ready for  : $uuid"

    set xcmd [list $cmd $repo $uuid {*}$cargs]

    if {![catch {
	puts ".......... : $xcmd"
	exec >@ stdout 2>@ stderr {*}$xcmd
	incr count
    } msg]} {
	DB transaction {
	    DB eval {
		INSERT INTO STATE.done VALUES ( $uuid )
	    }
	}
    } else {
	puts "FAIL: $msg"
	break
    }
}

DB close

puts "Processed: $count"
exit 0
